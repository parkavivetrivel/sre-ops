input {
  beats {
    port => 5044
  }
}

filter {
  grok {
    match => { "message" => [
      "%{TIMESTAMP_ISO8601:timestamp} \[%{WORD:level}\](?: \[trace=%{UUID:trace_id}\])?(?: \[user=%{DATA:user_id}\])?(?: \[route=%{DATA:route}\])?(?: \[duration_ms=%{NUMBER:duration_ms}\])?\s*%{GREEDYDATA:msg}"
    ] }
    overwrite => ["message"]
    tag_on_failure => ["_grokparsefailure"]
  }

  # Extract key=value fields from the msg part when present
  if [msg] {
    grok {
      match => {
        "msg" => "event=%{WORD:event}(?: error_type=%{WORD:error_type})?(?: order_id=%{DATA:order_id})?(?: amount=%{NUMBER:amount})?"
      }
      tag_on_failure => []
    }
  }

  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss,SSS" ]
    target => "@timestamp"
    timezone => "UTC"
    remove_field => [ "timestamp" ]
  }

  if [duration_ms] {
    mutate {
      convert => { "duration_ms" => "float" }
    }
  }

  if [docker][container][name] {
    mutate {
      add_field => { "service" => "%{[docker][container][name]}" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "logs-%{+YYYY.MM.dd}"
  }

  stdout { codec => rubydebug }
}
